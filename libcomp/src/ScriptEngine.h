/**
 * @file libcomp/src/ScriptEngine.h
 * @ingroup libcomp
 *
 * @author COMP Omega <compomega@tutanota.com>
 *
 * @brief Class to manage Squirrel scripting.
 *
 * This file is part of the COMP_hack Library (libcomp).
 *
 * Copyright (C) 2012-2018 COMP_hack Team <compomega@tutanota.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef LIBCOMP_SRC_SCRIPTENGINE_H
#define LIBCOMP_SRC_SCRIPTENGINE_H

// libcomp Includes
#include "CString.h"

// Squirrel Includes
#include <squirrel.h>
#include <sqstdblob.h>

// Sqrat includes
#include "PushIgnore.h"
#include <sqrat.h>
#include "PopIgnore.h"

// Standard C++11 Includes
#include <functional>
#include <set>
#include <unordered_map>

namespace libcomp
{

/**
 * Represents a Sqrat based Squirrel virtual machine handler to facilitate
 * script execution and bind @ref Object instances to the VM.
 */
class ScriptEngine : public std::enable_shared_from_this<ScriptEngine>
{
public:
    /**
     * Create the VM.
     * @param useRawPrint Set this to not prefix messages with "SQUIRREL: ".
     */
    ScriptEngine(bool useRawPrint = false);

    /**
     * Clean up the VM.
     */
    ~ScriptEngine();

    /**
     * Signifies that the templated type will be used in the VM instance.
     * Implementations of this function are generated by objgen when the
     * object is flagged as "scriptEnabled". Multiple calls to this function
     * will not bind the object multiple times.
     * @return Reference back to the engine so they can be chained
     */
    template <class T> ScriptEngine& Using();

    /**
     * Get the Sqrat VM.
     * @return The Sqrat VM
     */
    HSQUIRRELVM GetVM();

    /**
     * Get a pointer to the script engine.
     * @returns Pointer to the script engine.
     */
    std::shared_ptr<ScriptEngine> Self();

    /**
     * Get a pointer to the script engine.
     * @returns Pointer to the script engine.
     */
    std::shared_ptr<const ScriptEngine> Self() const;

    /**
     * Get a pointer to the script engine from a Squirrel handle.
     * @param vm Squirrel handle to the virtual machine.
     * @returns Pointer to the script engine.
     */
    static std::shared_ptr<ScriptEngine> Self(HSQUIRRELVM vm);

    /**
     * Evaluate a Squirrel script block as a string.
     * @param source Squirrel script block as a string
     * @return true on success, false on failure
     */
    bool Eval(const String& source, const String& sourceName = String());

    /**
     * Import a Squirrel binding module into the virtual machine.
     * @param module Name of the module to import.
     * @returns true if the module was imported, false otherwise.
     */
    bool Import(const std::string& module);

    /**
     * Load an include file (triggeded by a script).
     * @param path Path to the script to include.
     * @returns true if the script loaded, false otherwise.
     */
    bool Include(const std::string& path);

    /**
     * Register a script module that can be imported.
     * @param module Name of the module to import.
     * @param func Function to call to import the module.
     */
    void RegisterModule(const std::string& module, const std::function<
        bool(ScriptEngine&, const std::string& module)>& func);

private:
    /**
     * Utility function to complete the binding of an object via @ref ScriptEngine::Using.
     * @param name The name of the binding which should match a class name
     * @param binding The object binding
     */
    template <class T, class A> void Bind(const std::string& name,  Sqrat::Class<T, A>& binding)
    {
        mBindings.insert(name);
        Sqrat::RootTable(mVM).Bind(name.c_str(), binding);
    }

    /**
     * Check if an object has already been bound.
     * @param name The name of the binding to check
     * @param lockBinding Optional parameter to mark the binding as known
     *  now instead of waiting until calling @ref ScriptEngine::Bind. Useful
     *  for static functions or when circular references can occur.
     * @return true if it was bound already, false if it was not
     */
    bool BindingExists(const std::string& name, bool lockBinding = false);

    /**
     * Initialize the built-in script modules.
     */
    void InitializeBuiltins();

    /// The Sqrat VM
    HSQUIRRELVM mVM;

    /// Bindings that have already been made to objects via @ref ScriptEngine::Using
    std::set<std::string> mBindings;

    /// Imports that have already been made.
    std::set<std::string> mImports;

    /// If the logging system should be used or not.
    bool mUseRawPrint;

    /// Map of functions to import a script module.
    static std::unordered_map<std::string, std::function<bool(ScriptEngine&,
        const std::string& module)>> mModules;
};

} // namespace libcomp

#endif // LIBCOMP_SRC_SCRIPTENGINE_H
